(* type xxx = XXX of int [@@deriving gt {show} ] *)
(* let () = *)
(*   print_endline @@ GT.(show xxx) (XXX 666) *)

type 'a logic = Var of int | Value of 'a [@@deriving gt { show } ]

type t = N | S of t logic [@@deriving gt { show } ]

type 'a llist = Nil | Cons of 'a logic * 'a llist logic [@@deriving gt { show } ]




(* type lam = X of string logic | App of lam logic * lam logic | Abs of string logic * lam logic [@@deriving gt { show } ] *)
(* type typ = V of string logic | Arr of typ logic * typ logic  [@@deriving gt { show } ] *)
(* type token = Id | Add | Mul [@@deriving gt { show } ] *)
(* type expr  = I | A of expr logic * expr logic | M of expr logic * expr logic [@@deriving gt { show } ] *)
(* type t = N | A of t logic [@@deriving gt { show } ] *)



(* type lam = X of string logic | App of lam logic * lam logic | Abs of string logic * lam logic [@@deriving gt { show } ] *)
(* type typ = V of string logic | Arr of typ logic * typ logic  [@@deriving gt { show } ] *)

(* type token = Id | Add | Mul [@@deriving gt { show } ] *)
(* type expr  = I | A of expr logic * expr logic | M of expr logic * expr logic [@@deriving gt { show } ] *)

(* type nat = O | S of nat logic [@@deriving gt { show } ] *)
(* type 'a nat2 = *)
(*   | JustAlpha of 'a *)
(*   | Myself of 'a nat2 *)
(*   | LogicMyself of 'a nat2 logic *)
(*   | LogicLogicMyself of 'a nat2 logic logic [@@deriving gt { show } ] *)

(* class type virtual ['a,'ia,'sa,'inh,'syn] logic_tt = *)
(*   object *)
(*     method  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> 'syn *)
(*     method  t_logic : ('ia -> 'a -> 'sa) -> 'inh -> 'a logic -> 'syn *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,unit) *)
(*      GT.t)= *)
(*   let rec logic_gcata fa trans inh subj = *)
(*     let rec self = logic_gcata fa trans *)
(*     and tpo = object method a = fa end in *)
(*     match subj with *)
(*     | Var p0 -> trans#c_Var inh (GT.make self subj tpo) p0 *)
(*     | Value p0 -> *)
(*         trans#c_Value inh (GT.make self subj tpo) (GT.make fa p0 tpo) in *)
(*   { GT.gcata = logic_gcata; GT.plugins = () } *)
(* class virtual ['a,'ia,'sa,'inh,'syn] logic_t = *)
(*   object (this) *)
(*     method virtual  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method virtual  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> 'syn *)
(*     method t_logic fa = (GT.transform logic) fa this *)
(*   end *)
(* class type ['a] show_logic_env_tt = object  end *)
(* class ['a] show_proto_logic env = *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     method c_Var inh subj p0 = *)
(*       "Var " ^ (GT.transform GT.int (new GT.show_int_t) () p0) *)
(*     method c_Value inh subj p0 = "Value " ^ (p0.GT.fx ()) *)
(*   end *)
(* class ['a] show_logic_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     inherit  (['a] show_proto_logic self) *)
(*     initializer self := (this :> 'a show_logic_t) *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,< *)
(*                                                                     show *)
(*                                                                     :('a -> *)
(*                                                                     string) *)
(*                                                                     -> *)
(*                                                                     'a logic *)
(*                                                                     -> *)
(*                                                                     string  >) *)
(*      GT.t)= *)
(*   { *)
(*     GT.gcata = (logic.GT.gcata); *)
(*     GT.plugins = *)
(*       (object *)
(*          method show fa = *)
(*            (GT.transform logic) (GT.lift fa) (new show_logic_t) () *)
(*        end) *)
(*   } *)
(* class type virtual ['inh,'syn] nat_tt = *)
(*   object *)
(*     method  c_O : 'inh -> ('inh,nat,'syn,<  >) GT.a -> 'syn *)
(*     method  c_S : 'inh -> ('inh,nat,'syn,<  >) GT.a -> nat logic -> 'syn *)
(*     method  t_nat : 'inh -> nat -> 'syn *)
(*   end *)
(* let (nat :(('inh,'syn)#nat_tt -> 'inh -> nat -> 'syn,unit) GT.t)= *)
(*   let rec nat_gcata trans inh subj = *)
(*     let rec self = nat_gcata trans *)
(*     and tpo = object  end in *)
(*     match subj with *)
(*     | O  -> trans#c_O inh (GT.make self subj tpo) *)
(*     | S p0 -> trans#c_S inh (GT.make self subj tpo) p0 in *)
(*   { GT.gcata = nat_gcata; GT.plugins = () } *)
(* class virtual ['inh,'syn] nat_t = *)
(*   object (this) *)
(*     method virtual  c_O : 'inh -> ('inh,nat,'syn,<  >) GT.a -> 'syn *)
(*     method virtual  c_S : *)
(*       'inh -> ('inh,nat,'syn,<  >) GT.a -> nat logic -> 'syn *)
(*     method t_nat = (GT.transform nat) this *)
(*   end *)
(* class type show_nat_env_tt = object  end *)
(* class ['a] show_proto_nat env = *)
(*   object (this) *)
(*     inherit  [unit,string] nat_t *)
(*     method c_O inh subj = "O" *)
(*     method c_S inh subj p0 = "S " ^ (p0.GT.fx ()) *)
(*   end *)
(* class ['a] show_nat_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  [unit,string] nat_t *)
(*     inherit  (['a] show_proto_nat self) *)
(*     initializer self := (this :> 'a show_nat_t) *)
(*   end *)
(* let (nat *)
(*   :(('inh,'syn)#nat_tt -> 'inh -> nat -> 'syn,< show :nat -> string  >) GT.t)= *)
(*   { *)
(*     GT.gcata = (nat.GT.gcata); *)
(*     GT.plugins = *)
(*       (object method show = (GT.transform nat) (new show_nat_t) () end) *)
(*   } *)


(* class type virtual ['a,'ia,'sa,'inh,'syn] logic_tt = *)
(*   object *)
(*     method  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> 'syn *)
(*     method  t_logic : ('ia -> 'a -> 'sa) -> 'inh -> 'a logic -> 'syn *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,unit) *)
(*      GT.t)= *)
(*   let rec logic_gcata fa trans inh subj = *)
(*     let rec self = logic_gcata fa trans *)
(*     and tpo = object method a = fa end in *)
(*     match subj with *)
(*     | Var p0 -> trans#c_Var inh (GT.make self subj tpo) p0 *)
(*     | Value p0 -> *)
(*         trans#c_Value inh (GT.make self subj tpo) (GT.make fa p0 tpo) in *)
(*   { GT.gcata = logic_gcata; GT.plugins = () } *)
(* class virtual ['a,'ia,'sa,'inh,'syn] logic_t = *)
(*   object (this) *)
(*     method virtual  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method virtual  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> 'syn *)
(*     method t_logic fa = (GT.transform logic) fa this *)
(*   end *)
(* class type ['a] show_logic_env_tt = object  end *)
(* class ['a] show_proto_logic env = *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     method c_Var inh subj p0 = *)
(*       "Var " ^ (GT.transform GT.int (new GT.show_int_t) () p0) *)
(*     method c_Value inh subj p0 = "Value " ^ (p0.GT.fx ()) *)
(*   end *)
(* class ['a] show_logic_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     inherit  (['a] show_proto_logic self) *)
(*     initializer self := (this :> 'a show_logic_t) *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,< *)
(*                                                                     show *)
(*                                                                     :('a -> *)
(*                                                                     string) *)
(*                                                                     -> *)
(*                                                                     'a logic *)
(*                                                                     -> *)
(*                                                                     string  >) *)
(*      GT.t)= *)
(*   { *)
(*     GT.gcata = (logic.GT.gcata); *)
(*     GT.plugins = *)
(*       (object *)
(*          method show fa = *)
(*            (GT.transform logic) (GT.lift fa) (new show_logic_t) () *)
(*        end) *)
(*   } *)

(* class type virtual ['inh,'syn] nat_tt = *)
(*   object *)
(*     method  c_O : 'inh -> ('inh,nat,'syn,<  >) GT.a -> 'syn *)
(*     method  c_S : *)
(*       'inh -> *)
(*         ('inh,nat,'syn,<  >) GT.a -> ('inh,nat logic,'syn,<  >) GT.a -> 'syn *)
(*     method  t_nat : 'inh -> nat -> 'syn *)
(*   end *)
(* let (nat :(('inh,'syn)#nat_tt -> 'inh -> nat -> 'syn,unit) GT.t)= *)
(*   let rec nat_gcata trans inh subj = *)
(*     let rec self = nat_gcata trans *)
(*     and tpo = object  end in *)
(*     match subj with *)
(*     | O  -> trans#c_O inh (GT.make self subj tpo) *)
(*     | S p0 -> trans#c_S inh (GT.make self subj tpo) p0 in *)
(*   { GT.gcata = nat_gcata; GT.plugins = () } *)
(* class virtual ['inh,'syn] nat_t = *)
(*   object (this) *)
(*     method virtual  c_O : 'inh -> ('inh,nat,'syn,<  >) GT.a -> 'syn *)
(*     method virtual  c_S : *)
(*       'inh -> *)
(*         ('inh,nat,'syn,<  >) GT.a -> ('inh,nat logic,'syn,<  >) GT.a -> 'syn *)
(*     method t_nat = (GT.transform nat) this *)
(*   end *)
(* class type show_nat_env_tt = object  end *)
(* class ['a] show_proto_nat env = *)
(*   object (this) *)
(*     inherit  [unit,string] nat_t *)
(*     method c_O inh subj = "O" *)
(*     method c_S inh subj p0 = "S " ^ (p0.GT.fx ()) *)
(*   end *)
(* class ['a] show_nat_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  [unit,string] nat_t *)
(*     inherit  (['a] show_proto_nat self) *)
(*     initializer self := (this :> 'a show_nat_t) *)
(*   end *)
(* let (nat *)
(*   :(('inh,'syn)#nat_tt -> 'inh -> nat -> 'syn,< show :nat -> string  >) GT.t)= *)
(*   { *)
(*     GT.gcata = (nat.GT.gcata); *)
(*     GT.plugins = *)
(*       (object method show = (GT.transform nat) (new show_nat_t) () end) *)
(*   } *)




(* class type virtual ['a,'ia,'sa,'inh,'syn] logic_tt = *)
(*   object *)
(*     method  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  t_logic : ('ia -> 'a -> 'sa) -> 'inh -> 'a logic -> 'syn *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,unit) *)
(*      GT.t)= *)
(*   let rec logic_gcata a trans inh subj = *)
(*     let rec self = (logic_gcata a) trans *)
(*     and tpo = object method a = fa end in *)
(*     match subj with *)
(*     | Var p0 -> trans#c_Var inh (GT.make self subj tpo) p0 *)
(*     | Value (p0,p1) -> *)
(*         trans#c_Value inh (GT.make self subj tpo) (GT.make fa p0 tpo) p1 in *)
(*   { GT.gcata = logic_gcata; GT.plugins = () } *)
(* class virtual ['a,'ia,'sa,'inh,'syn] logic_t = *)
(*   object (this) *)
(*     method virtual  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method virtual  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method t_logic a = GT.transform logic (fun a  -> this) *)
(*   end *)
(* class type ['a] show_logic_env_tt = object  end *)
(* class ['a] show_proto_logic env = *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     method c_Var inh subj p0 = *)
(*       "Var " ^ (GT.transform GT.int (new GT.show_int_t) () p0) *)
(*     method c_Value inh subj p0 p1 = *)
(*       "Value (" ^ *)
(*         ((String.concat ", " *)
(*             [p0.GT.fx (); GT.transform GT.int (new GT.show_int_t) () p1]) *)
(*            ^ ")") *)
(*   end *)
(* class ['a] show_logic_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     inherit  (['a] show_proto_logic self) *)
(*     initializer self := (this :> 'a show_logic_t) *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,< *)
(*                                                                     show *)
(*                                                                     :'a -> *)
(*                                                                     'a logic *)
(*                                                                     -> *)
(*                                                                     string  >) *)
(*      GT.t)= *)
(*   { *)
(*     GT.gcata = (logic.GT.gcata); *)
(*     GT.plugins = *)
(*       (object *)
(*          method show a = *)
(*            (GT.transform logic) (GT.lift a) (new show_logic_t) () *)
(*        end) *)
(*   } *)



(* type 'a megalist = Nil | Cons of 'a * 'a megalist  [@@deriving gt { show } ] *)

(* let () = *)
(*   print_endline @@ GT.(show logic @@ show megalist @@ show int) *)
(*                      (Value (Cons (5, Nil), 18) ) *)

(* type 'a logic2 = Var of int |  Value of 'a [@@deriving gt { show } ] *)

(* let () = *)
(*   print_endline @@ GT.(show logic2 @@ show int) (Value 20); *)
(*   print_endline @@ GT.(show logic2 @@ show string) (Value "asdf"); *)
(*   () *)

(* type t = N | A of t logic [@@deriving gt { show } ] *)


(* type ident = [`Var of string] [@@ deriving gt] *)

(* class ['v] ident_eval = object *)
(*   inherit [string -> 'v, 'v] ident [@@deriving inher] *)
(*   method c_Var s _ x = s x *)
(* end *)

(* type 'a arith = [ `Add of 'a * 'a | `Sub of 'a * 'a]  [@@ deriving gt] *)

(* class ['a, 'b] arith_eval = object *)
(*   inherit ['a, 'b, int, 'b, int] arith [@@deriving inher] *)
(*   method c_Add inh _ x y = x.GT.fx inh + y.GT.fx inh *)
(*   method c_Sub inh _ x y = x.GT.fx inh - y.GT.fx inh *)
(* end *)

(* type 'a expr = [ ident | 'a arith ]  [@@ deriving gt] *)

(* class ['a] expr_eval = object(this) *)
(*   inherit ['a, string->int, int, string->int, int] expr [@@deriving inher] *)
(*   inherit [int] ident_eval *)
(*   inherit ['a, string -> int] arith_eval *)
(* end *)

(* let _ = *)
(*   let rec eval f x = GT.transform(expr) eval (new expr_eval) f x in *)
(*   Printf.printf "%d\n" (eval (function "x" -> 1 | "y" -> 2) (`Add (`Var "x", `Var "y"))) *)
