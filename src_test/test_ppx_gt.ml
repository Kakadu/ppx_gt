(* type xxx = XXX of int [@@deriving gt {show} ] *)
(* let () = *)
(*   print_endline @@ GT.(show xxx) (XXX 666) *)

type 'a logic = Var of GT.int |  Value of 'a * GT.int [@@deriving gt { show } ]


(* class type virtual ['a,'ia,'sa,'inh,'syn] logic_tt = *)
(*   object *)
(*     method  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method  t_logic : ('ia -> 'a -> 'sa) -> 'inh -> 'a logic -> 'syn *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,unit) *)
(*      GT.t)= *)
(*   let rec logic_gcata a trans inh subj = *)
(*     let rec self = (logic_gcata a) trans *)
(*     and tpo = object method a = fa end in *)
(*     match subj with *)
(*     | Var p0 -> trans#c_Var inh (GT.make self subj tpo) p0 *)
(*     | Value (p0,p1) -> *)
(*         trans#c_Value inh (GT.make self subj tpo) (GT.make fa p0 tpo) p1 in *)
(*   { GT.gcata = logic_gcata; GT.plugins = () } *)
(* class virtual ['a,'ia,'sa,'inh,'syn] logic_t = *)
(*   object (this) *)
(*     method virtual  c_Var : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method virtual  c_Value : *)
(*       'inh -> *)
(*         ('inh,'a logic,'syn,< a :'ia -> 'a -> 'sa  >) GT.a -> *)
(*           ('ia,'a,'sa,< a :'ia -> 'a -> 'sa  >) GT.a -> GT.int -> 'syn *)
(*     method t_logic a = GT.transform logic (fun a  -> this) *)
(*   end *)
(* class type ['a] show_logic_env_tt = object  end *)
(* class ['a] show_proto_logic env = *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     method c_Var inh subj p0 = *)
(*       "Var " ^ (GT.transform GT.int (new GT.show_int_t) () p0) *)
(*     method c_Value inh subj p0 p1 = *)
(*       "Value (" ^ *)
(*         ((String.concat ", " *)
(*             [p0.GT.fx (); GT.transform GT.int (new GT.show_int_t) () p1]) *)
(*            ^ ")") *)
(*   end *)
(* class ['a] show_logic_t = let self = Obj.magic (ref ()) in *)
(*   object (this) *)
(*     inherit  ['a,unit,string,unit,string] logic_t *)
(*     inherit  (['a] show_proto_logic self) *)
(*     initializer self := (this :> 'a show_logic_t) *)
(*   end *)
(* let (logic *)
(*   :(('ia -> 'a -> 'sa) -> *)
(*       ('a,'ia,'sa,'inh,'syn)#logic_tt -> 'inh -> 'a logic -> 'syn,< *)
(*                                                                     show *)
(*                                                                     :'a -> *)
(*                                                                     'a logic *)
(*                                                                     -> *)
(*                                                                     string  >) *)
(*      GT.t)= *)
(*   { *)
(*     GT.gcata = (logic.GT.gcata); *)
(*     GT.plugins = *)
(*       (object *)
(*          method show a = *)
(*            (GT.transform logic) (GT.lift a) (new show_logic_t) () *)
(*        end) *)
(*   } *)



(* type 'a megalist = Nil | Cons of 'a * 'a megalist  [@@deriving gt { show } ] *)

(* let () = *)
(*   print_endline @@ GT.(show logic @@ show megalist @@ show int) *)
(*                      (Value (Cons (5, Nil), 18) ) *)

(* type 'a logic2 = Var of int |  Value of 'a [@@deriving gt { show } ] *)

(* let () = *)
(*   print_endline @@ GT.(show logic2 @@ show int) (Value 20); *)
(*   print_endline @@ GT.(show logic2 @@ show string) (Value "asdf"); *)
(*   () *)

(* type t = N | A of t logic [@@deriving gt { show } ] *)


(* type ident = [`Var of string] [@@ deriving gt] *)

(* class ['v] ident_eval = object *)
(*   inherit [string -> 'v, 'v] ident [@@deriving inher] *)
(*   method c_Var s _ x = s x *)
(* end *)

(* type 'a arith = [ `Add of 'a * 'a | `Sub of 'a * 'a]  [@@ deriving gt] *)

(* class ['a, 'b] arith_eval = object *)
(*   inherit ['a, 'b, int, 'b, int] arith [@@deriving inher] *)
(*   method c_Add inh _ x y = x.GT.fx inh + y.GT.fx inh *)
(*   method c_Sub inh _ x y = x.GT.fx inh - y.GT.fx inh *)
(* end *)

(* type 'a expr = [ ident | 'a arith ]  [@@ deriving gt] *)

(* class ['a] expr_eval = object(this) *)
(*   inherit ['a, string->int, int, string->int, int] expr [@@deriving inher] *)
(*   inherit [int] ident_eval *)
(*   inherit ['a, string -> int] arith_eval *)
(* end *)

(* let _ = *)
(*   let rec eval f x = GT.transform(expr) eval (new expr_eval) f x in *)
(*   Printf.printf "%d\n" (eval (function "x" -> 1 | "y" -> 2) (`Add (`Var "x", `Var "y"))) *)
